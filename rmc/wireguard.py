from pathlib import Path
from subprocess import Popen, PIPE
import subprocess
import os


class WireguardServer_macOS:
    """ Performs all setup for a Wireguard macOS server. Must be run as root """

    def __init__(self, force_reset=False, config=None,
                        port=51820, subnet = "9.0.0.0/24"):

        if config is not None:
            self.subnet = config['auth']['subnet']
            self.port = config['wireguard']['port']
            self.pk = config['wireguard']['pk']
            self.Pk = config['wireguard']['Pk']
            self.update_config(config['userlist'])
            return

        self.subnet = subnet
        self.port = port

        # -------- Setup for the first time:

        sh_path = Path("/usr/local/etc/wireguard/")
        if not sh_path.exists():
            sh_path.mkdir(parents=True)

        # all backslashes escaped as \\ so they don't disappear (and wreak havoc)
        postup = (f"""#!/bin/sh

# 1) Preparing the directory which we'll persist the pf token
#    generated by (2) in. That token can then be used by our
#    postdown.sh script to remove the routing rule in the
#    event Wireguard is shut down on the server.
mkdir -p /usr/local/var/run/wireguard
chmod 700 /usr/local/var/run/wireguard

# 2) Dynamically add the NAT rule, enable the firewall, increase
#    its reference count (-E) and persist the reference token
#    generated by the command into pf_wireguard_token.txt,
#    which postdown.sh will reference when Wireguard is shut
#    down.
echo 'nat on en0 from {self.subnet} to any -> (en0)' | \\
    pfctl -a com.apple/wireguard -Ef - 2>&1 | \\
    grep 'Token' | \\
    sed 's%Token : \\(.*\\)%\\1%' > /usr/local/var/run/wireguard/pf_wireguard_token.txt""")

        # print(postup)

        with open('/usr/local/etc/wireguard/postup.sh', 'w') as postup_file:
            postup_file.write(postup)


        postdown = ("""#!/bin/sh

# 1) Fetch the pf reference token that was generated on
#    Wireguard startup with postup.sh
TOKEN=`cat /usr/local/var/run/wireguard/pf_wireguard_token.txt`

# 2) Remove the reference (and by extension, the pf rule that
#    generated it). Adding and removing rules by references
#    like this will automatically disable the packet filter
#    firewall if there are no other references left, but will
#    leave it up and intact if there are.
pfctl -X ${TOKEN} || exit 1
rm -f /usr/local/var/run/wireguard/pf_wireguard_token.txt""")

        # print(postdown)

        with open('/usr/local/etc/wireguard/postdown.sh', 'w') as postdown_file:
            postdown_file.write(postdown)

        # -------- Make executable

        try:
            assert(os.system("chmod u+x /usr/local/etc/wireguard/*.sh") == 0)
        except AssertionError:
            print("Could not make file executable. Running app as sudo?")

        # -------- Configure

        self.pk, self.Pk = self.pk_Pk_pair()

    def update_config(self, userlist):
        ''' Overwrite the config with the current userlist'''

        # Interface always first
        server_config = (f"""
[Interface]
# Substitute with the subnet you chose for Wireguard earlier.
Address = {self.subnet}
# Substitute with your *server's* private key
PrivateKey = {self.pk}
# If you chose a different port earlier when setting up port
# forwarding on your router, update the port here to match.
ListenPort = {self.port}
# This prevents IPv4 & IPv6 DNS leaks when browsing the web on the
# VPN. I chose Cloudflare's public DNS servers, but feel free to use
# whatever provider you prefer.
DNS = 1.1.1.1, 8.8.8.8
# This ensures our peers continue to report their Wireguard-
# assigned IPs while connected to the VPN. This is required for
# their traffic to get routed correctly by the firewall rules we
# crafted earlier with pf.
PostUp = /usr/sbin/sysctl -w net.inet.ip.forwarding=1
PostUp = /usr/sbin/sysctl -w net.inet6.ip6.forwarding=1
# Adds the firewall routing rule on Wireguard server startup
PostUp = /usr/local/etc/wireguard/postup.sh
# Removes the firewall routing rule on Wireguard server shutdown
PostDown = /usr/local/etc/wireguard/postdown.sh
        """)

        print(f">>> Added Server to config")

        # Peers

        for n, user in enumerate(userlist[1:]):

            # Authentication occured?
            if user['Pk'] != "":

                print(f">>> Added {user['name']}, {user['Pk']}, {user['ip']} to config")

                server_config += (f"""

# USER {n}: {user['name']}
[Peer]
# Substitute with *this peer*'s public key
PublicKey = {user['Pk']}
# Chose a unique IP within the Wireguard subnet you defined earlier
# that this particular peer will use when connected to the VPN.
AllowedIPs = {user['ip']}/32
                """)

        if self.state:
            self.down()
            do_up = True
        else:
            do_up = False

        with open("/usr/local/etc/wireguard/server.conf", 'w') as conf:
            conf.write(server_config)

        if do_up:
            self.up()

    @property
    def state(self):
        if self.peers():
            # Check if already running, and update if so
            return True
        else:
            return False

    def up(self):

        # already up?
        if self.state:
            # Check if already running, and update state if so
            return
        else:
            up = subprocess.check_output("sudo wg-quick up /usr/local/etc/wireguard/server.conf",
                                            shell=True, stderr=subprocess.STDOUT)
            print(str(up,'utf-8'))

    def show(self):
        show = subprocess.check_output("sudo wg show", shell=True, stderr=subprocess.STDOUT)
        print(str(output,'utf-8')) # returns empty if

    def down(self):
        if not self.state:
            return

        down = subprocess.check_output("sudo wg-quick down /usr/local/etc/wireguard/server.conf", shell=True, stderr=subprocess.STDOUT)
        print(str(down,'utf-8'))

    def pk_Pk_pair(self):

        os.system("umask 077") # Ensure credentials don't leak from possible race condition.
        os.system("wg genkey | tee privatekey | wg pubkey > publickey")

        with open('privatekey','r') as pk_file:
            pk = pk_file.read().strip()

        with open('publickey','r') as Pk_file:
            Pk = Pk_file.read().strip()

        Path("privatekey").unlink() # (delete)
        Path("publickey").unlink() # (delete)

        return pk, Pk

    def peers(self):
        """ Returns a dict containing all peers in the Server config.
                like: {Pk: {'ip':'...', 'handshake': True}}
        """


        proc = Popen(['wg','show'], stdout=PIPE, stderr=PIPE)
        wg, err = proc.communicate()
        wg = str(wg,'utf-8')

        peers = {}

        if "peer: " in wg:
            peers_conf = wg.split("peer: ")

            # [1:] because interface/server is 0
            for peer in peers_conf[1:]:

                Pk = peer.split('\n')[0]
                handshake = False

                for row in peer.split('\n'):
                    if 'allowed ips' in row:
                        ip = row.strip().split(':')[1].strip()

                    if 'handshake' in row:
                        handshake = True

                peers[Pk] = {"ip": ip, 'handshake':handshake}

        return peers
