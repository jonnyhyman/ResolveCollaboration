from pathlib import Path
import os

from ipaddress import ip_address, ip_network

from subprocess import Popen, PIPE
import subprocess

from util.sudoscience import elevated_check_output, elevated_Popen, elevated_system
import tempfile

class WireguardServer_macOS:
    """ Performs all setup for a Wireguard macOS server """

    def __init__(self, force_reset=False, config=None,
                        port=51820, subnet = "9.0.0.0/24"):

        if config is not None and force_reset==False:
            self.subnet = config['auth']['subnet']
            self.port = config['wireguard']['port']
            self.pk = config['wireguard']['pk']
            self.Pk = config['wireguard']['Pk']
            return

        self.subnet = subnet
        self.port = port

        # -------- Setup for the first time:

        temp_dir = Path("/tmp/wireguard")
        temp_dir.mkdir(exist_ok=True) # temp directory

        # all backslashes escaped as \\ so they don't disappear (and wreak havoc)
        postup = (f"""#!/bin/sh

# 1) Preparing the directory which we'll persist the pf token
#    generated by (2) in. That token can then be used by our
#    postdown.sh script to remove the routing rule in the
#    event Wireguard is shut down on the server.
mkdir -p /usr/local/var/run/wireguard
chmod 700 /usr/local/var/run/wireguard

# 2) Dynamically add the NAT rule, enable the firewall, increase
#    its reference count (-E) and persist the reference token
#    generated by the command into pf_wireguard_token.txt,
#    which postdown.sh will reference when Wireguard is shut
#    down.
echo 'nat on en0 from {self.subnet} to any -> (en0)' | \\
    pfctl -a com.apple/wireguard -Ef - 2>&1 | \\
    grep 'Token' | \\
    sed 's%Token : \\(.*\\)%\\1%' > /usr/local/var/run/wireguard/pf_wireguard_token.txt""")

        # print(postup)

        # requires sudo to write
        with open(temp_dir / 'postup.sh', 'w') as postup_file:
            postup_file.write(postup)

        postdown = ("""#!/bin/sh

# 1) Fetch the pf reference token that was generated on
#    Wireguard startup with postup.sh
TOKEN=`cat /usr/local/var/run/wireguard/pf_wireguard_token.txt`

# 2) Remove the reference (and by extension, the pf rule that
#    generated it). Adding and removing rules by references
#    like this will automatically disable the packet filter
#    firewall if there are no other references left, but will
#    leave it up and intact if there are.
pfctl -X ${TOKEN} || exit 1
rm -f /usr/local/var/run/wireguard/pf_wireguard_token.txt""")

        # print(postdown)

        with open(temp_dir / 'postdown.sh', 'w') as postdown_file:
            postdown_file.write(postdown)

        # -------- Copy files and Make executable

        try:
            output = elevated_system(
                ("mkdir --parents /usr/local/etc/wireguard/; "
                "mv -f /tmp/wireguard/postup.sh /usr/local/etc/wireguard/postup.sh; "
                "mv -f /tmp/wireguard/postdown.sh /usr/local/etc/wireguard/postdown.sh; "
                "chmod u+x /usr/local/etc/wireguard/*.sh"),
                prompt=("Resolve Mission Control wants to create and change "
                        "execution privileges on Wireguard files")
            )

            assert(output == 0)
            print(">>> Set up wireguard server!")

        except AssertionError:
            raise(PermissionError("Could not run sudo commands to set up Wireguard"))

        # -------- Configure

        self.pk, self.Pk = self.pk_Pk_pair()

    def write_config(self, server_config):

        temp_dir = Path("/tmp/wireguard")
        temp_dir.mkdir(exist_ok=True) # temp directory

        with open(temp_dir / "server.conf", 'w') as conf:
            conf.write(server_config)

        elevated_system(
            "mv -f /tmp/wireguard/server.conf /usr/local/etc/wireguard/server.conf",
            prompt=("Resolve Mission Control wants to overwrite the "
                    "Wireguard server configuration")
        )


    def update_config(self, userlist):
        ''' Overwrite the config with the current userlist'''

        first_ip = next(ip_network(self.subnet).hosts())

        # Interface always first
        server_config = (f"""
[Interface]
# Substitute with the subnet you chose for Wireguard earlier.
Address = {first_ip}/32
# Substitute with your *server's* private key
PrivateKey = {self.pk}
# If you chose a different port earlier when setting up port
# forwarding on your router, update the port here to match.
ListenPort = {self.port}
# This prevents IPv4 & IPv6 DNS leaks when browsing the web on the VPN
DNS = 1.1.1.1, 8.8.8.8, 2001:4860:4860::8888
# This ensures our peers continue to report their Wireguard-
# assigned IPs while connected to the VPN. This is required for
# their traffic to get routed correctly by the firewall rules we
# crafted earlier with pf.
PostUp = /usr/sbin/sysctl -w net.inet.ip.forwarding=1
PostUp = /usr/sbin/sysctl -w net.inet6.ip6.forwarding=1
# Adds the firewall routing rule on Wireguard server startup
PostUp = /usr/local/etc/wireguard/postup.sh
# Removes the firewall routing rule on Wireguard server shutdown
PostDown = /usr/local/etc/wireguard/postdown.sh
        """)

        print(f">>> Added Server to config")

        # Peers

        for n, user in enumerate(userlist[1:]):

            # Authentication occured?
            if user['Pk'] != "":

                print(f">>> Added {user['name']}, {user['Pk']}, {user['ip']} to config")

                server_config += (f"""

# USER {n}: {user['name']}
[Peer]
# Substitute with *this peer*'s public key
PublicKey = {user['Pk']}
# Chose a unique IP within the Wireguard subnet you defined earlier
# that this particular peer will use when connected to the VPN.
AllowedIPs = {user['ip']}/32
                """)

        if self.state:
            self.down()
            do_up = True
        else:
            do_up = False

        self.write_config(server_config)

        if do_up:
            self.up()

    def show(self):
        try:
            wg = elevated_Popen("sudo wg show",
                prompt='Resolve Mission Control wants to check the status of Wireguard')
            return wg
        except PermissionError:
            return ""

    @property
    def state(self):
        return self.show().strip() != "" # True if wireguard running

    def up(self):

        # check if wireguard is up, if not, do up
        cmd = ( '''if [[ $(sudo wg show) == "" ]]; '''
                '''then sudo wg-quick up /usr/local/etc/wireguard/server.conf; '''
                '''else echo "... Wireguard already up"; fi''' )
        try:
            up = elevated_Popen(
                    cmd, prompt=("Resolve Mission Control wants to start Wireguard")
            )
        except PermissionError:
            return ' failed to go'

        if 'Wireguard already' in up:
            return ' already'
        else:
            return ''

    def down(self):

        # check if wireguard is down, if no, do down
        cmd = ( '''if [[ $(sudo wg show) != "" ]]; '''
                '''then sudo wg-quick down /usr/local/etc/wireguard/server.conf; '''
                '''else echo "... Wireguard already down"; fi''' )
        try:
            down = elevated_Popen(
                    cmd, prompt=("Resolve Mission Control wants to stop Wireguard")
            )
        except PermissionError:
            return ' failed to go'

        if 'Wireguard already' in down:
            return ' already'
        else:
            return ''

    def pk_Pk_pair(self):

        # Ensure credentials don't leak from possible race condition.
        os.system("umask 077")

        # Get the keys
        os.system("wg genkey | tee privatekey | wg pubkey > publickey")

        with open('privatekey','r') as pk_file:
            pk = pk_file.read().strip()

        with open('publickey','r') as Pk_file:
            Pk = Pk_file.read().strip()

        Path("privatekey").unlink() # (delete)
        Path("publickey").unlink() # (delete)

        return pk, Pk

    def peers(self):
        """ Returns a dict containing all peers in the Server config.
                like: {Pk: {'ip':'...', 'handshake': True}}
        """

        wg = self.show()

        peers = {}

        if "peer: " in wg:
            peers_conf = wg.split("peer: ")

            # [1:] because interface/server is 0
            for peer in peers_conf[1:]:

                Pk = peer.split('\n')[0]
                handshake = False

                for row in peer.split('\n'):
                    if 'allowed ips' in row:
                        ip = row.strip().split(':')[1].strip()

                    if 'handshake' in row:
                        handshake = True

                peers[Pk] = {"ip": ip, 'handshake':handshake}

        return peers
